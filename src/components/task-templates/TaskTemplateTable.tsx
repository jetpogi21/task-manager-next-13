//Generated by WriteToModeltable_tsx - ModelTable.tsx for Table 9/18
"use client";
import React, { useEffect } from "react";
import {
  TaskTemplateFormikInitialValues,
  TaskTemplateModel,
  TaskTemplateSearchParams,
} from "@/interfaces/TaskTemplateInterfaces";
import { useQueryClient } from "@tanstack/react-query";
import { useModelsQuery, useUpdateModelsMutation } from "@/hooks/useModelQuery";
import { TaskTemplateConfig } from "@/utils/config/TaskTemplateConfig";
import { BasicModel, GetModelsResponse } from "@/interfaces/GeneralInterfaces";
import { useModelPageParams } from "@/hooks/useModelPageParams";
import { getCurrentData } from "@/lib/getCurrentData";
import { getRefetchQueryFunction } from "@/lib/refetchQuery";
import { useTableProps } from "@/hooks/useTableProps";
import ModelDataTable from "@/components/ModelDataTable";
import { createRequiredModelLists } from "@/lib/createRequiredModelLists";
import { getInitialValues } from "@/lib/getInitialValues";
import { toast } from "@/hooks/use-toast";
import { Formik, FormikProps } from "formik";
import { ModelSchema } from "@/schema/ModelSchema";
import TaskTemplateSingleColumn from "@/components/task-templates/TaskTemplateSingleColumn";
import useGlobalDialog from "@/hooks/useGlobalDialog";
import TaskTemplateForm from "@/components/task-templates/TaskTemplateForm";
import { Row } from "@tanstack/react-table";
import { findModelPrimaryKeyField } from "@/utils/utilities";

const TaskTemplateTable = <T,>({
  tableStates,
}: {
  tableStates: ReturnType<typeof useTableProps<T>>;
}) => {
  const modelConfig = TaskTemplateConfig;
  const primaryKeyFieldName = findModelPrimaryKeyField(modelConfig).fieldName;
  const { pluralizedModelName } = modelConfig;
  const pageParams = useModelPageParams<TaskTemplateSearchParams>(modelConfig);
  const { params } = pageParams;
  const queryClient = useQueryClient();

  const [mounted, setMounted] = React.useState(false);

  //For Editable Tables
  const requiredList: Record<string, BasicModel[]> =
    createRequiredModelLists(modelConfig);

  //For Editable Tables
  const defaultFormValue = getInitialValues<T>(modelConfig, undefined, {
    childMode: true,
    requiredList,
  });

  //Store Variables
  const {
    page,
    setRecordCount,
    fetchCount,
    setFetchCount,
    currentData: previousData,
    setCurrentData,
    setIsUpdating,
  } = tableStates;

  const queryParams = params;

  const useTaskTemplateSearchQuery = () =>
    useModelsQuery<T>(modelConfig, {
      ...queryParams,
      fetchCount: fetchCount.toString(),
    });

  const queryResponse = useTaskTemplateSearchQuery();
  const { data, refetch, isFetching } = queryResponse;

  const currentPageData: GetModelsResponse<T> | null = data
    ? data.pages[page - (isFetching ? 2 : 1)]
    : null;
  const currentData = getCurrentData(
    currentPageData,
    previousData,
    modelConfig.isTable ? false : defaultFormValue
  );

  //Client functions
  const refetchQuery = getRefetchQueryFunction(
    modelConfig,
    params,
    refetch,
    queryClient
  );

  //Add any required mutations here
  /* 
  const addTaskTemplatesFromTemplateMutation =
    useImportTaskTemplateFromTemplate((data) => {
      refetchQuery(0);
    });
  const modelActions = {
    "Add Form Templates": addTaskTemplatesFromTemplateMutation,
  }; 
  */
  const modelActions = undefined;

  const { mutate: updateRecords, mutateAsync: asyncUpdateRecords } =
    useUpdateModelsMutation(modelConfig);
  const rowActions = undefined;
  /* 
  const rowActions = getTaskTemplateRowActions({
    currentData,
    setCurrentData,
    mutate: updateRecords,
  }); 
  */

  const columnsToBeOverriden = undefined;
  /* 
  const columnsToBeOverriden = getTaskColumnsToBeOverriden<
    T,
    unknown
  >();
  */

  const handleSubmit = async (values: TaskTemplateFormikInitialValues) => {
    //The reference is the index of the row
    const rowsToBeSubmitted = (
      values[
        pluralizedModelName as keyof TaskTemplateFormikInitialValues
      ] as TaskTemplateFormikInitialValues["TaskTemplates"]
    ).filter((item) => item.touched);

    if (rowsToBeSubmitted.length > 0) {
      setIsUpdating(true);
      const payload = {
        [pluralizedModelName]: rowsToBeSubmitted,
      };

      //@ts-ignore
      asyncUpdateRecords(payload).then((data) => {
        console.log(data);
        setIsUpdating(false);
        toast({
          variant: "success",
          description: `${modelConfig.pluralizedVerboseModelName} successfully updated`,
        });
      });
    }
  };

  const { openDialog, closeDialog } = useGlobalDialog();

  const openDialogHandler = (row?: Row<T>["original"]) => {
    openDialog({
      title: `${modelConfig.verboseModelName} Form`,
      message: (
        <div className="pt-8">
          <TaskTemplateForm
            data={(row ? row : null) as TaskTemplateModel | null}
            id={
              row
                ? (row[primaryKeyFieldName as keyof typeof row] as string)
                : "new"
            }
            modalFormProps={{
              onSuccess: () => {
                closeDialog();
                refetchQuery(page - 1);
              },
            }}
          />
        </div>
      ),
      formMode: true,
    });
  };

  const dialogFormProps = { openDialogHandler };

  /* const columnOrderToOverride: [string, number][] = [["isFinished", 2]]; */
  const columnOrderToOverride = undefined;

  useEffect(() => {
    setMounted(true);
    return () => {
      setMounted(false);
    };
  }, []);

  useEffect(() => {
    if (currentPageData?.count !== undefined) {
      setRecordCount(currentPageData?.count || 0);
    }
    setFetchCount(!fetchCount);
    setCurrentData(currentData);
  }, [currentPageData?.count, data, page]);

  const commonProps = {
    modelConfig,
    tableStates,
    refetchQuery,
    queryResponse,
    pageParams,
    rowActions,
    modelActions,
    SingleColumnComponent: TaskTemplateSingleColumn,
    requiredList,
    defaultFormValue,
    columnOrderToOverride,
  };

  return (
    mounted &&
    (modelConfig.isTable ? (
      <ModelDataTable
        {...commonProps}
        columnsToBeOverriden={columnsToBeOverriden}
        dialogFormProps={modelConfig.isModal ? dialogFormProps : undefined}
      />
    ) : (
      <Formik
        initialValues={
          {
            [pluralizedModelName]: currentData,
          } as unknown as TaskTemplateFormikInitialValues
        }
        enableReinitialize={true}
        onSubmit={handleSubmit}
        validationSchema={ModelSchema(modelConfig, true)}
        validateOnChange={false}
      >
        {(formik) => (
          <ModelDataTable
            {...commonProps}
            formik={formik as unknown as FormikProps<T>}
          />
        )}
      </Formik>
    ))
  );
};

export default TaskTemplateTable;
