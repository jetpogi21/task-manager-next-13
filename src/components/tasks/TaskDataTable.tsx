//Generated by WriteToModeldatatable_tsx - ModelDataTable.tsx
import { ModelDeleteDialog } from "@/components/ModelDeleteDialog";
import TaskSingleColumn from "@/components/tasks/TaskSingleColumn";
import { TaskSpecialDataTable } from "@/components/tasks/TaskSpecialDataTable";
import { Button, buttonVariants } from "@/components/ui/Button";
import { useImportTaskFromTemplate } from "@/hooks/tasks/useImportTaskFromTemplate";
import { useTaskStore } from "@/hooks/tasks/useTaskStore";
import useGlobalDialog from "@/hooks/useGlobalDialog";
import { useModelPageParams } from "@/hooks/useModelPageParams";
import { useUpdateModelsMutation } from "@/hooks/useModelQuery";
import useScreenSize from "@/hooks/useScreenSize";
import { GetModelsResponse } from "@/interfaces/GeneralInterfaces";
import { TaskModel, TaskSearchParams } from "@/interfaces/TaskInterfaces";
import { generateActionButtons } from "@/lib/generateActionButtons";
import { getModelColumns } from "@/lib/getModelColumns";
import { getTaskRowActions } from "@/lib/tasks/getTaskRowActions";
import { cn } from "@/lib/utils";
import { TaskConfig } from "@/utils/config/TaskConfig";
import { getSorting } from "@/utils/utilities";
import { encodeParams } from "@/utils/utils";
import { UseInfiniteQueryResult } from "@tanstack/react-query";
import {
  useReactTable,
  getCoreRowModel,
  SortingState,
} from "@tanstack/react-table";
import { Trash } from "lucide-react";
import Link from "next/link";
import React, { useEffect, useState } from "react";

interface TaskDataTableProps {
  taskQuery: () => UseInfiniteQueryResult<
    GetModelsResponse<TaskModel>,
    unknown
  >;
}

const modelConfig = TaskConfig;
const TaskDataTable: React.FC<TaskDataTableProps> = ({ taskQuery }) => {
  const {
    pathname,
    router,
    params: pageParams,
  } = useModelPageParams<TaskSearchParams>(modelConfig);
  const { sort, limit } = pageParams;

  const isLarge = useScreenSize("lg");

  //Zustand states
  const {
    resetRowSelection,
    rowSelection,
    setRowSelection,
    setRowSelectionToAll,
    page,
    recordCount,
    setRecordCount,
    setPage,
    lastFetchedPage,
    currentData,
    setCurrentData,
    setLastFetchedPage,
    refetchQuery,
  } = useTaskStore((state) => ({
    resetRowSelection: state.resetRowSelection,
    rowSelection: state.rowSelection,
    setRowSelection: state.setRowSelection,
    setRowSelectionToAll: state.setRowSelectionToAll,
    page: state.page,
    recordCount: state.recordCount,
    setRecordCount: state.setRecordCount,
    setPage: state.setPage,
    lastFetchedPage: state.lastFetchedPage,
    currentData: state.currentData,
    setCurrentData: state.setCurrentData,
    setLastFetchedPage: state.setLastFetchedPage,
    refetchQuery: state.refetchQuery,
  }));

  const { closeDialog, openDialog } = useGlobalDialog((state) => ({
    closeDialog: state.closeDialog,
    openDialog: state.openDialog,
  }));

  const [recordsToDelete, setRecordsToDelete] = useState<string[]>([]);

  //Page Constants

  //Tanstacks
  const { data: taskData, isLoading, isFetching, fetchNextPage } = taskQuery();

  const {
    mutate: mutateImportTask,
    isLoading: isImportTaskLoading,
    isError: isImportTaskError,
    error: importTaskError,
  } = useImportTaskFromTemplate(() => {
    setPage(1);
    setLastFetchedPage(1);
    refetchQuery && refetchQuery(0);
  });

  //Transformations
  const sorting = getSorting(sort);
  const hasSelected = Object.values(rowSelection).some((val) => val);
  const dataRowCount = taskData
    ? currentData.length + (page - 1) * parseInt(limit)
    : 0;
  const pageStatus = `Showing ${dataRowCount} of ${recordCount} record(s)`;
  const hasPreviousPage = page > 1;
  const hasNextPage = dataRowCount < recordCount;
  const indexes = Object.keys(rowSelection)
    .filter((key) => rowSelection[key])
    .map((item) => parseInt(item));

  //Utility Functions
  const { mutate } = useUpdateModelsMutation(modelConfig);
  const rowActions = getTaskRowActions({
    currentData,
    setCurrentData,
    mutate,
  });

  //Client Actions
  const deleteRow = (idx: number) => {
    const id = currentData[idx].id;

    if (id) {
      setRecordsToDelete([id.toString()]);
    }
  };

  const deleteSelectedRows = () => {
    //Compute the Ids to be deleted. the index should be the selected indexes. then see if the rows has an actual id value
    const deletedIDs = currentData
      .filter((_, idx) => indexes.includes(idx))
      .filter((item) => !!item.id)
      .map((item) => item.id.toString());

    if (deletedIDs.length > 0) {
      setRecordsToDelete(deletedIDs);
    }
  };

  const toggleRow = (idx: number) => setRowSelection(idx);
  const toggleSelectAllRow = () => {
    if (Object.keys(rowSelection).length === currentData.length) {
      resetRowSelection();
    } else {
      setRowSelectionToAll(currentData.length);
    }
  };

  const goToPreviousPage = () => {
    if (taskData) {
      const newPage = page - 1;
      setPage(newPage);
      resetRowSelection();
    }
  };

  const goToNextPage = () => {
    if (taskData) {
      const newPage = page + 1;

      if (newPage > lastFetchedPage) {
        fetchNextPage();
        setLastFetchedPage(newPage);
      }

      setPage(newPage);
      resetRowSelection();
    }
  };

  const handleSortChange = (sortingState: SortingState) => {
    const sortParams = sortingState
      .map((item) => {
        if (item.desc) {
          return `-${item.id}`;
        } else {
          return `${item.id}`;
        }
      })
      .join(",");

    setPage(1);
    setLastFetchedPage(1);
    resetRowSelection();
    const params = { ...pageParams, sort: sortParams };
    const newURL = `${pathname}?${encodeParams(params)}`;
    router.push(newURL);
  };

  const columnVisibility: Record<string, boolean> = modelConfig.fields.reduce(
    (acc: Record<string, boolean>, field) => {
      if (field.hideInTable) {
        acc[field.fieldName] = false;
      } else {
        acc[field.fieldName] = !isLarge;
      }
      return acc;
    },
    { singleColumn: isLarge }
  );

  const taskTable = useReactTable<TaskModel>({
    data: currentData,
    columns: getModelColumns({
      modelConfig,
      ModelSingleColumn: TaskSingleColumn,
    }),
    state: {
      sorting: sorting,
      rowSelection,
    },
    //@ts-ignore
    onRowSelectionChange: (state) => setRowSelection(state()),
    //@ts-ignore
    onSortingChange: (state) => handleSortChange(state()), //since the sort state is getting tracked from the url do handle instead
    getCoreRowModel: getCoreRowModel(),
    manualFiltering: true,
    manualSorting: true,
    enableMultiRowSelection: true,
    initialState: {
      columnVisibility: columnVisibility,
    },
    meta: {
      name: modelConfig.pluralizedModelName,
      deleteRow,
      toggleRow,
      toggleSelectAllRow,
      editable: false,
      rowActions,
    },
  });

  useEffect(() => {
    taskTable.getAllColumns().forEach((column) => {
      if (
        ![
          "select",
          "actions",
          ...modelConfig.fields
            .filter((item) => item.hideInTable)
            .map((item) => item.fieldName),
        ].includes(column.id)
      ) {
        if (column.id === "singleColumn") {
          column.toggleVisibility(isLarge);
        } else {
          column.toggleVisibility(!isLarge);
        }
      }
    });
  }, [isLarge]);

  return (
    <>
      <div className="flex flex-col flex-1 gap-4">
        <div className="flex flex-col-reverse items-start gap-4 lg:flex-row lg:items-center">
          <div className="w-full text-sm">
            {taskTable.getFilteredSelectedRowModel().rows.length} of{" "}
            {taskTable.getFilteredRowModel().rows.length} row(s) selected.
          </div>
          <div
            className={cn(
              "flex gap-4 items-center",
              isLarge && "fixed",
              hasSelected &&
                "fixed left-0 right-0 m-auto bottom-6 border-2 border-border w-[90%] bg-background p-4 z-10 rounded-lg shadow-sm"
            )}
          >
            {hasSelected && (
              <div className="flex gap-4">
                <Button
                  type="button"
                  size={"sm"}
                  variant={"destructive"}
                  onClick={deleteSelectedRows}
                  className="flex items-center justify-center gap-2"
                >
                  Delete Selected
                  <Trash className="w-4 h-4 text-foreground" />
                </Button>
                {generateActionButtons(
                  rowActions,
                  indexes,
                  openDialog,
                  closeDialog,
                  resetRowSelection
                )}
              </div>
            )}
          </div>
          <div className="flex items-end w-full space-x-4">
            <Link
              className={cn(
                buttonVariants({ variant: "secondary", size: "sm" }),
                "ml-auto"
              )}
              href={`/${modelConfig.modelPath}/new`}
            >
              Add New
            </Link>
            <Button
              isLoading={isImportTaskLoading}
              variant={"secondary"}
              size="sm"
              onClick={() => {
                mutateImportTask();
              }}
            >
              Add From Templates
            </Button>
          </div>
        </div>

        <div className="border rounded-md">
          <TaskSpecialDataTable
            table={taskTable}
            isLoading={isLoading}
          />
        </div>
        <div className="flex items-center justify-between mt-auto text-sm select-none text-muted-foreground">
          {!isLoading && (
            <div className="flex flex-col items-center justify-between w-full gap-4 lg:flex-row">
              <p>{pageStatus}</p>
              <div className="flex gap-2">
                <Button
                  type="button"
                  size="sm"
                  variant={"secondary"}
                  disabled={!hasPreviousPage}
                  onClick={() => goToPreviousPage()}
                >
                  Previous
                </Button>
                <Button
                  type="button"
                  size="sm"
                  variant={"secondary"}
                  disabled={!hasNextPage || isFetching}
                  onClick={() => goToNextPage()}
                  isLoading={isFetching}
                >
                  Next
                </Button>
              </div>
            </div>
          )}
        </div>
      </div>
      <ModelDeleteDialog
        modelConfig={modelConfig}
        recordsToDelete={recordsToDelete}
        setRecordsToDelete={setRecordsToDelete}
        onSuccess={() => {
          setRecordsToDelete([]);
          setRecordCount(
            recordCount -
              currentData.filter((item) =>
                recordsToDelete.includes(item.id.toString())
              ).length
          );
          resetRowSelection();
          refetchQuery && refetchQuery(page - 1);
        }}
      />
    </>
  );
};

export default TaskDataTable;
