//Generated by WriteToModeldatatable_tsx - ModelDataTable.tsx
import { ModelDeleteDialog } from "@/components/ModelDeleteDialog";
import { ModelRowActions } from "@/components/ModelRowActions";
import { Button, buttonVariants } from "@/components/ui/Button";
import { DataTable } from "@/components/ui/DataTable";
import useGlobalDialog from "@/hooks/useGlobalDialog";
import { useModelPageParams } from "@/hooks/useModelPageParams";
import useScreenSize from "@/hooks/useScreenSize";
import { useTableProps } from "@/hooks/useTableProps";
import {
  ArrayOfUnknownObject,
  BasicModel,
  GetModelsResponse,
  PrimaryKey,
  UnknownObject,
} from "@/interfaces/GeneralInterfaces";
import { ModelConfig } from "@/interfaces/ModelConfig";
import { generateActionButtons } from "@/lib/generateActionButtons";
import { getModelColumns } from "@/lib/getModelColumns";
import { cn } from "@/lib/utils";
import {
  findModelPrimaryKeyField,
  forceCastToNumber,
  getSorting,
} from "@/utils/utilities";
import { encodeParams, removeItemsByIndexes } from "@/utils/utils";
import {
  UseInfiniteQueryResult,
  UseMutationResult,
} from "@tanstack/react-query";
import {
  useReactTable,
  getCoreRowModel,
  SortingState,
  CellContext,
} from "@tanstack/react-table";
import { Form, FormikProps } from "formik";
import { Plus, Trash } from "lucide-react";
import Link from "next/link";
import React, { ReactNode, useEffect, useMemo, useRef, useState } from "react";

type CustomUseMutationResult<T> = UseMutationResult<
  {
    data: T;
  },
  unknown,
  void,
  unknown
>;

interface ModelActions<T> {
  [key: string]: CustomUseMutationResult<T>;
}

interface ModelDataTableProps<T, U, V> {
  modelConfig: ModelConfig;
  tableStates: ReturnType<typeof useTableProps<T>>;
  refetchQuery: (idx: number) => void;
  queryResponse: UseInfiniteQueryResult<GetModelsResponse<T>, unknown>;
  pageParams: ReturnType<typeof useModelPageParams<U>>;
  SingleColumnComponent?: React.FC<{ cell: CellContext<T, unknown> }>;
  rowActions?: ModelRowActions;
  modelActions?: ModelActions<V>;
  requiredList?: Record<string, BasicModel[]>;
  defaultFormValue?: T;
  formik?: FormikProps<T>;
}

const ModelDataTable = <T, U, V>({
  modelConfig,
  tableStates,
  refetchQuery,
  queryResponse,
  pageParams,
  SingleColumnComponent,
  rowActions,
  modelActions,
  requiredList,
  defaultFormValue,
  formik,
}: ModelDataTableProps<T, U, V>) => {
  const { query, pathname, router, params } = pageParams;
  const { sort, limit } = params;

  const primaryKeyFieldName = findModelPrimaryKeyField(modelConfig).fieldName;
  const { pluralizedModelName } = modelConfig;

  const isLarge = useScreenSize("lg");

  //Zustand states
  const {
    resetRowSelection,
    rowSelection,
    setRowSelection,
    setRowSelectionToAll,
    setRowSelectionByIndex,
    page,
    recordCount,
    setRecordCount,
    setPage,
    lastFetchedPage,
    currentData,
    setCurrentData,
    setLastFetchedPage,
    isUpdating,
  } = tableStates;

  const inferredCurrentData = currentData as ArrayOfUnknownObject;

  const { closeDialog, openDialog } = useGlobalDialog((state) => ({
    closeDialog: state.closeDialog,
    openDialog: state.openDialog,
  }));

  const [recordsToDelete, setRecordsToDelete] = useState<string[]>([]);
  const [willFocus, setWillFocus] = useState(false);
  const ref: React.RefObject<HTMLElement> = useRef(null); //to be attached to the last row in form, first control in that row

  //Page Constants

  //Tanstacks
  const { data, isLoading, isFetching, fetchNextPage } = queryResponse;

  //Transformations
  const sorting = getSorting(sort);
  const hasSelected = Object.values(rowSelection).some((val) => val);
  const dataRowCount = data
    ? currentData.length + (page - 1) * forceCastToNumber(limit)
    : 0;
  const pageStatus = `Showing ${dataRowCount} of ${recordCount} record(s)`;
  const hasPreviousPage = page > 1;
  const hasNextPage = dataRowCount < recordCount;
  const indexes = Object.keys(rowSelection)
    .filter((key) => rowSelection[key])
    .map((item) => parseInt(item));
  const rows = formik
    ? ((formik.values as UnknownObject)[
        pluralizedModelName
      ] as ArrayOfUnknownObject)
    : [];
  //Utility Functions

  //Client Actions
  const focusOnRef = () => {
    ref && ref.current?.focus();
  };

  const addRow = () => {
    formik!.setFieldValue(pluralizedModelName, [
      ...rows.map((item) => ({ ...item })),
      { ...defaultFormValue },
    ]);
    setWillFocus(true);
  };

  const setTouchedRows = (idx: number) => {
    formik!.setFieldValue(`${pluralizedModelName}[${idx}].touched`, true);
  };

  const deleteRow = (idx: number) => {
    const id = formik
      ? (rows[idx][primaryKeyFieldName] as PrimaryKey)
      : (inferredCurrentData[idx][primaryKeyFieldName] as PrimaryKey);

    if (id) {
      setRecordsToDelete([id.toString()]);
    } else {
      formik!.setFieldValue(pluralizedModelName, [
        ...rows.slice(0, idx),
        ...rows.slice(idx + 1),
      ]);
      formik!.setErrors({});
      resetRowSelection();
    }
  };

  const deleteSelectedRows = () => {
    //Compute the Ids to be deleted. the index should be the selected indexes. then see if the rows has an actual id value
    const deletedIDs = inferredCurrentData
      .filter(
        (item, idx) =>
          indexes.includes(idx) && !!(item[primaryKeyFieldName] as PrimaryKey)
      )
      .map((item) => item[primaryKeyFieldName]!.toString());

    if (deletedIDs.length > 0) {
      setRecordsToDelete(deletedIDs);
    } else {
      formik!.setFieldValue(
        pluralizedModelName,
        removeItemsByIndexes(rows, indexes)
      );
      formik!.setErrors({});
      resetRowSelection();
    }
  };

  //
  const toggleRow = (idx: number) => setRowSelectionByIndex(idx);
  const toggleSelectAllRow = () => {
    if (Object.keys(rowSelection).length === currentData.length) {
      resetRowSelection();
    } else {
      setRowSelectionToAll(currentData.length);
    }
  };

  const goToPreviousPage = () => {
    if (data) {
      const newPage = page - 1;
      setPage(newPage);
      resetRowSelection();
    }
  };

  const goToNextPage = () => {
    if (data) {
      const newPage = page + 1;

      if (newPage > lastFetchedPage) {
        fetchNextPage();
        setLastFetchedPage(newPage);
      }

      setPage(newPage);
      resetRowSelection();
    }
  };

  const handleSortChange = (sortingState: SortingState) => {
    const sortParams = sortingState
      .map((item) => {
        if (item.desc) {
          return `-${item.id}`;
        } else {
          return `${item.id}`;
        }
      })
      .join(",");

    setPage(1);
    setLastFetchedPage(1);
    resetRowSelection();
    const params = { ...query, sort: sortParams };
    const newURL = `${pathname}?${encodeParams(params)}`;
    router.push(newURL);
  };

  const columnVisibility: Record<string, boolean> = modelConfig.fields.reduce(
    (acc: Record<string, boolean>, field) => {
      if (field.hideInTable) {
        acc[field.fieldName] = false;
      } else {
        acc[field.fieldName] = !isLarge;
      }
      return acc;
    },
    { singleColumn: isLarge }
  );

  let firstFieldInForm: string = "";
  let lastFieldInForm: string = "";
  modelConfig.fields
    .filter((field) => !field.hideInTable)
    .sort((a, b) => {
      return a.fieldOrder - b.fieldOrder;
    })
    .forEach((field, index) => {
      if (index === 0) {
        firstFieldInForm = field.fieldName;
      }
      lastFieldInForm = field.fieldName;
    });

  const modelColumns = useMemo(
    () =>
      getModelColumns<T, unknown>({
        modelConfig,
        ModelSingleColumn: SingleColumnComponent,
      }),
    [modelConfig]
  );

  const modelTable = useReactTable<T>({
    data: (formik ? rows : currentData) as T[],
    columns: modelColumns,
    state: {
      sorting: sorting,
      rowSelection,
    },
    //@ts-ignore
    onRowSelectionChange: (state) => setRowSelection(state()),
    //@ts-ignore
    onSortingChange: (state) => handleSortChange(state()), //since the sort state is getting tracked from the url do handle instead
    getCoreRowModel: getCoreRowModel(),
    manualFiltering: true,
    manualSorting: true,
    enableMultiRowSelection: true,
    initialState: {
      columnVisibility,
    },
    meta: {
      name: modelConfig.pluralizedModelName,
      setTouchedRows,
      addRow,
      deleteRow,
      toggleRow,
      toggleSelectAllRow,
      firstFieldInForm: firstFieldInForm,
      lastFieldInForm: lastFieldInForm,
      forwardedRef: ref,
      editable: !modelConfig.isTable,
      rowActions,
      options: {},
    },
  });

  useEffect(() => {
    if (willFocus) {
      focusOnRef();
    }
  }, [rows]);

  useEffect(() => {
    modelTable.getAllColumns().forEach((column) => {
      if (
        ![
          "select",
          "actions",
          ...modelConfig.fields
            .filter((item) => item.hideInTable)
            .map((item) => item.fieldName),
        ].includes(column.id)
      ) {
        if (column.id === "singleColumn") {
          column.toggleVisibility(isLarge);
        } else {
          column.toggleVisibility(!isLarge);
        }
      }
    });
  }, [isLarge]);

  const TableWrapper = ({ children }: { children: ReactNode }) => {
    if (modelConfig.isTable) {
      return <div className="flex flex-col flex-1 gap-4">{children}</div>;
    } else {
      return (
        <Form
          className="flex flex-col flex-1 gap-4"
          autoComplete="off"
          noValidate
        >
          {children}
        </Form>
      );
    }
  };

  return (
    <>
      <TableWrapper>
        <div className="flex flex-col-reverse items-start gap-4 lg:flex-row lg:items-center">
          <div className="w-full text-sm">
            {modelTable.getFilteredSelectedRowModel().rows.length} of{" "}
            {modelTable.getFilteredRowModel().rows.length} row(s) selected.
          </div>
          <div
            className={cn(
              "flex gap-4 items-center",
              isLarge && "fixed",
              hasSelected &&
                "fixed left-0 right-0 m-auto bottom-6 border-2 border-border w-[90%] bg-background p-4 z-10 rounded-lg shadow-sm"
            )}
          >
            {hasSelected && (
              <div className="flex gap-4">
                <Button
                  type="button"
                  size={"sm"}
                  variant={"destructive"}
                  onClick={deleteSelectedRows}
                  className="flex items-center justify-center gap-2"
                >
                  Delete Selected
                  <Trash className="w-4 h-4 text-foreground" />
                </Button>
                {generateActionButtons(
                  rowActions,
                  indexes,
                  openDialog,
                  closeDialog,
                  resetRowSelection
                )}
              </div>
            )}
          </div>
          <div className="flex items-end w-full space-x-4">
            <Link
              className={cn(
                buttonVariants({ variant: "secondary", size: "sm" }),
                "ml-auto"
              )}
              href={`/${modelConfig.modelPath}/new`}
            >
              Add New
            </Link>
            {modelActions
              ? Object.keys(modelActions).map((key) => {
                  const mutation = modelActions[key];
                  return (
                    <Button
                      isLoading={mutation.isLoading}
                      variant={"secondary"}
                      size="sm"
                      onClick={() => {
                        mutation.mutate();
                      }}
                    >
                      {key}
                    </Button>
                  );
                })
              : null}
          </div>
        </div>

        <div className="border rounded-md">
          <DataTable
            table={modelTable}
            isLoading={isLoading}
          />
        </div>
        <div className="flex items-center justify-between mt-auto text-sm select-none text-muted-foreground">
          {!isLoading && (
            <div className="flex flex-col items-center justify-between w-full gap-4 lg:flex-row">
              <p>{pageStatus}</p>
              <div className="flex gap-2">
                {!modelConfig.isTable && (
                  <>
                    <Button
                      type="button"
                      size="sm"
                      variant={"secondary"}
                      onClick={addRow}
                      isLoading={isUpdating}
                    >
                      <Plus className="w-4 h-4 mr-1 text-foreground" />
                      Add Row
                    </Button>
                    <Button
                      type="button"
                      size={"sm"}
                      isLoading={isUpdating}
                      variant={"secondary"}
                      onClick={() => formik!.submitForm()}
                    >
                      Save Changes
                    </Button>
                  </>
                )}
                <Button
                  type="button"
                  size="sm"
                  variant={"secondary"}
                  disabled={!hasPreviousPage}
                  onClick={() => goToPreviousPage()}
                >
                  Previous
                </Button>
                <Button
                  type="button"
                  size="sm"
                  variant={"secondary"}
                  disabled={!hasNextPage || isFetching}
                  onClick={() => goToNextPage()}
                  isLoading={isFetching}
                >
                  Next
                </Button>
              </div>
            </div>
          )}
        </div>
      </TableWrapper>
      <ModelDeleteDialog
        modelConfig={modelConfig}
        recordsToDelete={recordsToDelete}
        setRecordsToDelete={setRecordsToDelete}
        onSuccess={() => {
          setRecordsToDelete([]);
          setRecordCount(
            recordCount -
              inferredCurrentData.filter((item) =>
                recordsToDelete.includes(
                  (item[primaryKeyFieldName] as PrimaryKey)!.toString()
                )
              ).length
          );
          resetRowSelection();
          refetchQuery && refetchQuery(page - 1);
        }}
      />
    </>
  );
};

export default ModelDataTable;
