//Generated by WriteToModeltable_tsx - ModelTable.tsx for Table 9/18
//Generated by WriteToModeltable_tsx - ModelTable.tsx for Table 9/18
"use client";
import React, { useEffect } from "react";
import {
  TagFormikInitialValues,
  TagModel,
  TagSearchParams,
} from "@/interfaces/TagInterfaces";
import { useQueryClient } from "@tanstack/react-query";
import { useModelsQuery, useUpdateModelsMutation } from "@/hooks/useModelQuery";
import { TagConfig } from "@/utils/config/TagConfig";
import { BasicModel, GetModelsResponse } from "@/interfaces/GeneralInterfaces";
import { useModelPageParams } from "@/hooks/useModelPageParams";
import { getCurrentData } from "@/lib/getCurrentData";
import { getRefetchQueryFunction } from "@/lib/refetchQuery";
import { useTableProps } from "@/hooks/useTableProps";
import ModelDataTable from "@/components/ModelDataTable";
import { createRequiredModelLists } from "@/lib/createRequiredModelLists";
import { getInitialValues } from "@/lib/getInitialValues";
import { toast } from "@/hooks/use-toast";
import { Formik, FormikProps } from "formik";
import { ModelSchema } from "@/schema/ModelSchema";

const TagTable: React.FC = () => {
  const modelConfig = TagConfig;
  const { pluralizedModelName } = modelConfig;
  const pageParams = useModelPageParams<TagSearchParams>(modelConfig);
  const { params } = pageParams;
  const queryClient = useQueryClient();

  const [mounted, setMounted] = React.useState(false);

  //For Editable Tables
  const requiredList: Record<string, BasicModel[]> =
    createRequiredModelLists(modelConfig);

  //For Editable Tables
  const defaultFormValue = getInitialValues<TagModel>(modelConfig, undefined, {
    childMode: true,
    requiredList,
  });

  //Store Variables
  const tableStates = useTableProps<TagModel>(modelConfig);
  const {
    page,
    setRecordCount,
    fetchCount,
    setFetchCount,
    currentData: previousData,
    setCurrentData,
    setIsUpdating,
  } = tableStates;

  const queryParams = params;

  const useTagSearchQuery = () =>
    useModelsQuery<TagModel>(modelConfig, {
      ...queryParams,
      fetchCount: fetchCount.toString(),
    });

  const queryResponse = useTagSearchQuery();
  const { data, refetch, isFetching } = queryResponse;

  const currentPageData: GetModelsResponse<TagModel> | null = data
    ? data.pages[page - (isFetching ? 2 : 1)]
    : null;
  const currentData = getCurrentData(
    currentPageData,
    previousData,
    modelConfig.isTable ? false : defaultFormValue
  );

  //Client functions
  const refetchQuery = getRefetchQueryFunction(
    modelConfig,
    params,
    refetch,
    queryClient
  );

  //Add any required mutations here
  /* 
  const addTagsFromTemplateMutation =
    useImportTagFromTemplate((data) => {
      refetchQuery(0);
    });
  const modelActions = {
    "Add Form Templates": addTagsFromTemplateMutation,
  }; 
  */
  const modelActions = {};

  const { mutate: updateRecords, mutateAsync: asyncUpdateRecords } =
    useUpdateModelsMutation(modelConfig);
  const rowActions = undefined;
  /* 
  const rowActions = getTagRowActions({
    currentData,
    setCurrentData,
    mutate: updateRecords,
  }); 
  */

  const handleSubmit = async (values: TagFormikInitialValues) => {
    //The reference is the index of the row
    const rowsToBeSubmitted = (
      values[
        pluralizedModelName as keyof TagFormikInitialValues
      ] as TagFormikInitialValues["Tags"]
    ).filter((item) => item.touched);

    if (rowsToBeSubmitted.length > 0) {
      setIsUpdating(true);
      const payload = {
        [pluralizedModelName]: rowsToBeSubmitted,
      };

      //@ts-ignore
      asyncUpdateRecords(payload).then((data) => {
        console.log(data);
        setIsUpdating(false);
        toast({
          variant: "success",
          description: `${modelConfig.pluralizedVerboseModelName} successfully updated`,
        });
      });
    }
  };

  useEffect(() => {
    setMounted(true);
    return () => {
      setMounted(false);
    };
  }, []);

  useEffect(() => {
    if (currentPageData?.count !== undefined) {
      setRecordCount(currentPageData?.count || 0);
    }
    setFetchCount(!fetchCount);
    setCurrentData(currentData);
  }, [currentPageData?.count, data, page]);

  const commonProps = {
    modelConfig,
    tableStates,
    refetchQuery,
    queryResponse,
    pageParams,
    rowActions,
    modelActions,
    SingleColumnComponent: undefined,
    requiredList,
    defaultFormValue,
  };

  return (
    mounted &&
    (modelConfig.isTable ? (
      <ModelDataTable {...commonProps} />
    ) : (
      <Formik
        initialValues={
          {
            [pluralizedModelName]: currentData,
          } as unknown as TagFormikInitialValues
        }
        enableReinitialize={true}
        onSubmit={handleSubmit}
        validationSchema={ModelSchema(modelConfig, true)}
        validateOnChange={false}
      >
        {(formik) => (
          <ModelDataTable
            {...commonProps}
            formik={formik as unknown as FormikProps<TagModel>}
          />
        )}
      </Formik>
    ))
  );
};

export default TagTable;
