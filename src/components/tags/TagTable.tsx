//Generated by WriteToModeltable_tsx - ModelTable.tsx
"use client";
import React, { useEffect } from "react";
import { useTagStore } from "@/hooks/tags/useTagStore";
import {
  TagModel,
  TagSearchParams,
} from "@/interfaces/TagInterfaces";
import { useQueryClient } from "@tanstack/react-query";
import { Formik } from "formik";
import { TagConfig } from "@/utils/config/TagConfig";
import { useModelPageParams } from "@/hooks/useModelPageParams";
import { getInitialValues } from "@/lib/getInitialValues";
import { BasicModel, GetModelsResponse } from "@/interfaces/GeneralInterfaces";
import { createRequiredModelLists } from "@/lib/createRequiredModelLists";
import { useModelsQuery, useUpdateModelsMutation } from "@/hooks/useModelQuery";
import { ModelSchema } from "@/schema/ModelSchema";
import ModelFormArray from "@/components/ModelFormArray";
import { getCurrentData } from "@/lib/getCurrentData";
import { getRefetchQueryFunction } from "@/lib/refetchQuery";
import { toast } from "@/hooks/use-toast";

const TagTable: React.FC = () => {
  const modelConfig = TagConfig;
  const { pluralizedModelName } = modelConfig;
  const { params } = useModelPageParams<TagSearchParams>(modelConfig);
  const queryClient = useQueryClient();

  const [mounted, setMounted] = React.useState(false);

  const requiredList: Record<string, BasicModel[]> =
    createRequiredModelLists(modelConfig);

  //Page constants
  const defaultFormValue = getInitialValues(modelConfig, undefined, {
    childMode: true,
    requiredList,
  });

  //Store Variables
  const page = useTagStore((state) => state.page);
  const setRecordCount = useTagStore((state) => state.setRecordCount);
  const fetchCount = useTagStore((state) => state.fetchCount);
  const setFetchCount = useTagStore((state) => state.setFetchCount);
  const previousData = useTagStore((state) => state.currentData);
  const setCurrentData = useTagStore((state) => state.setCurrentData);
  const setQueryResponse = useTagStore(
    (state) => state.setQueryResponse
  );
  const setRefetchQuery = useTagStore(
    (state) => state.setRefetchQuery
  );

  const recordCount = useTagStore((state) => state.recordCount);
  const setIsUpdating = useTagStore((state) => state.setIsUpdating);
  const isUpdating = useTagStore((state) => state.isUpdating);
  const setPage = useTagStore((state) => state.setPage);
  const lastFetchedPage = useTagStore(
    (state) => state.lastFetchedPage
  );

  const queryParams = params;
  const useTagSearchQuery = () =>
    useModelsQuery<TagModel>(modelConfig, {
      ...params,
      fetchCount: fetchCount.toString(),
    });

  const queryResponse = useTagSearchQuery();
  const { data, refetch, isFetching } = queryResponse;

  const currentPageData: GetModelsResponse<TagModel> | null = data
    ? data.pages[page - (isFetching ? 2 : 1)]
    : null;
  const currentData: any[] = getCurrentData(
    currentPageData,
    previousData as any,
    defaultFormValue
  );

  //Client functions
  const refetchQuery = getRefetchQueryFunction(
    modelConfig,
    params,
    refetch,
    queryClient
  );

  const updateModelsMutation = useUpdateModelsMutation(modelConfig);

  //Client Actions
  const handleSubmit = async (values: any) => {
    //The reference is the index of the row
    //@ts-ignore
    const rowsToBeSubmitted = values[pluralizedModelName].filter(
      //@ts-ignore
      (item) => item.touched
    );

    if (rowsToBeSubmitted.length > 0) {
      setIsUpdating(true);
      const payload = {
        [pluralizedModelName]: rowsToBeSubmitted,
      };

      //@ts-ignore
      updateModelsMutation.mutateAsync(payload).then((data) => {
        console.log(data);
        setIsUpdating(false);
        toast({
          variant: "success",
          description: `${modelConfig.pluralizedVerboseModelName} successfully updated`,
        });
      });
    }
  };

  useEffect(() => {
    if (currentPageData?.count !== undefined) {
      setRecordCount(currentPageData?.count || 0);
    }
    setFetchCount(!fetchCount);
    setCurrentData(currentData);
    setRefetchQuery(refetchQuery);
  }, [currentPageData?.count, data, page]);

  useEffect(() => {
    setMounted(true);
  }, []);

  return (
    mounted && (
      <Formik
        initialValues={{
          [pluralizedModelName]: currentData,
        }}
        enableReinitialize={true}
        onSubmit={handleSubmit}
        validationSchema={ModelSchema(modelConfig, true)}
        validateOnChange={false}
      >
        {(formik) => (
          <ModelFormArray
            formik={formik as any}
            modelConfig={modelConfig}
            storeStates={{
              currentData,
              page,
              recordCount,
              isUpdating,
              setPage,
              lastFetchedPage,
              setRecordCount,
            }}
            queryResponse={queryResponse as any}
            refetchQuery={refetchQuery}
          />
        )}
      </Formik>
    )
  );
};

export default TagTable;
