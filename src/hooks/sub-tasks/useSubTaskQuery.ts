//Generated by WriteToUsemodelquery_ts - useModelQuery.ts
import {
  GetSubTasksResponse,
  SubTaskDeletePayload,
  SubTaskFormUpdatePayload,
  SubTaskModel,
  SubTaskSearchParams,
  SubTaskUpdatePayload,
} from "@/interfaces/SubTaskInterfaces";
import axiosClient from "@/utils/api";
import {
  DEFAULT_FILTERS,
  MODEL_PATH,
  PRIMARY_KEY,
} from "@/utils/constants/SubTaskConstants";
import { getAxiosParams } from "@/utils/utilities";
import {
  QueryMeta,
  UseQueryResult,
  useInfiniteQuery,
  useMutation,
  useQuery,
} from "@tanstack/react-query";

type IndexAndID = {
  index: number;
  id: number | string;
};

type Response = {
  id?: number | string;
  slug?: string;
};

export const updateSubTasks = async (payload: SubTaskUpdatePayload) => {
  const { data } = (await axiosClient({
    url: `${MODEL_PATH}/multi`,
    method: "post",
    data: payload,
  })) as { data: { recordsCreated: number } };

  return data;
};

export const deleteSubTasks = async (payload: SubTaskDeletePayload) => {
  const { data } = (await axiosClient({
    url: `${MODEL_PATH}`,
    method: "delete",
    data: payload,
  })) as { data: { recordsDeleted: number } };

  return data;
};

const updateSubTask = async (
  payload: SubTaskFormUpdatePayload,
  id: string | number
) => {
  const { data } = await axiosClient({
    url: MODEL_PATH + "/" + id,
    method: "put",
    data: payload,
  });

  return data as Response;
};

const addSubTask = async (payload: SubTaskFormUpdatePayload) => {
  const { data } = await axiosClient({
    url: MODEL_PATH,
    method: "post",
    data: payload,
  });

  return data as Response;
};

export const getSubTask = async ({
  queryKey,
}: {
  queryKey: [string, string];
}) => {
  const { data } = await axiosClient.get<SubTaskModel>(
    `${MODEL_PATH}/${queryKey[1]}`
  );
  return data;
};

const addOrUpdateSubTask = (payload: SubTaskFormUpdatePayload) => {
  if (payload[PRIMARY_KEY]) {
    return updateSubTask(payload, payload[PRIMARY_KEY]);
  } else {
    return addSubTask(payload);
  }
};

export const useSubTaskQuery = (
  slug: string,
  options?: Parameters<typeof useQuery>[2]
) => {
  const subTaskMutation = useMutation(addOrUpdateSubTask);

  const subTaskQuery = useQuery(
    ["subTask", slug],
    getSubTask,
    //@ts-ignore
    options
  ) as UseQueryResult<SubTaskModel, any>;

  return { subTaskMutation, subTaskQuery };
};

//Generated by GetCodeOriginallyFromModelTable - GetCodeOriginallyFromModelTable
interface GetSubTasksProps {
  pageParam?: string;
  queryKey: [string, Partial<SubTaskSearchParams>];
  meta: QueryMeta | undefined;
}
const getSubTasks = async ({
  pageParam = "",
  queryKey,
  meta,
}: GetSubTasksProps) => {
  const [_, { limit = "", sort = "" }] = queryKey;

  const { fetchCount } = meta!;

  const axiosParams = getAxiosParams(
    {
      //Generated by GetAllFilterQueryNameBySeqModel
    },
    DEFAULT_FILTERS,
    {
      cursor: pageParam,
      limit,
      sort,
      //@ts-ignore
      fetchCount: fetchCount.toString(),
    }
  ) as Partial<SubTaskSearchParams>;

  const { data } = await axiosClient.get<GetSubTasksResponse>(MODEL_PATH, {
    params: axiosParams,
  });

  return data;
};

interface UseSubTasksQueryProps extends Partial<SubTaskSearchParams> {}

export const useSubTasksQuery = ({
  //Generated by GetAllFilterQueryNameBySeqModel

  limit,
  sort,
  fetchCount,
}: UseSubTasksQueryProps) => {
  const _ = useInfiniteQuery(
    [
      "subTasks",
      {
        //Generated by GetAllFilterQueryNameBySeqModel

        limit,
        sort,
      },
    ],
    getSubTasks,
    {
      keepPreviousData: true,
      getNextPageParam: (lastPage) => lastPage.cursor ?? undefined,
      meta: {
        fetchCount,
      },
    }
  );
  return _;
};
