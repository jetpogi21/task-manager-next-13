import { GetModelsResponse } from "@/interfaces/GeneralInterfaces";
import { ModelConfig } from "@/interfaces/ModelConfig";
import axiosClient from "@/utils/api";
import { getAxiosParams, getDefaultFilters } from "@/utils/utilities";
import { QueryMeta, useInfiniteQuery } from "@tanstack/react-query";

export const updateModels = async <T>(payload: T, config: ModelConfig) => {
  const { data } = await axiosClient({
    url: `${config.modelPath}/multi`,
    method: "post",
    data: payload,
  });

  return data as unknown;
};

export const deleteModels = async (
  payload: Record<"deletedRecords", number[] | string[]>,
  config: ModelConfig
) => {
  const { data } = await axiosClient({
    url: `${config.modelPath}`,
    method: "delete",
    data: payload,
  });

  return data as unknown;
};

const updateModel = async (
  payload: Record<string, unknown>,
  id: string | number,
  config: ModelConfig
) => {
  const { data } = await axiosClient({
    url: config.modelPath + "/" + id,
    method: "put",
    data: payload,
  });

  return data as unknown;
};

const addModel = async (
  payload: Record<string, unknown>,
  config: ModelConfig
) => {
  const { data } = await axiosClient({
    url: config.modelPath,
    method: "post",
    data: payload,
  });

  return data as unknown;
};

interface GetModelProps {
  queryKey: [string, string];
  config: ModelConfig;
}

export const getModel = async <TModel>({ queryKey, config }: GetModelProps) => {
  const { data } = await axiosClient.get<TModel>(
    `${config.modelPath}/${queryKey[1]}`
  );
  return data;
};

const addOrUpdateModel = (
  payload: Record<string, unknown>,
  config: ModelConfig
) => {
  const primaryKeyField = config.fields.find(
    (field) => field.primaryKey
  )?.fieldName;
  if (payload[primaryKeyField!]) {
    return updateModel(
      payload,
      payload[primaryKeyField!] as string | number,
      config
    );
  } else {
    return addModel(payload, config);
  }
};

//Generated by GetCodeOriginallyFromModelTable - GetCodeOriginallyFromModelTable
interface GetModelsProps {
  pageParam?: string;
  queryKey: [string, Record<string, string>];
  meta: QueryMeta | undefined;
  config: ModelConfig;
}

const getModels = async <TModel>({
  pageParam = "",
  queryKey,
  meta,
  config,
}: GetModelsProps) => {
  const [_, { limit, sort, ...otherQueryKeys }] = queryKey;

  const { fetchCount } = meta!;
  const defaultFilters = getDefaultFilters(config.filters);

  const axiosParams = getAxiosParams(
    {
      ...(otherQueryKeys as Record<string, string>),
    },
    defaultFilters,
    {
      cursor: pageParam,
      limit,
      sort,
      //@ts-ignore
      fetchCount: fetchCount.toString(),
    }
  ) as Partial<TModel>;

  const { data } = await axiosClient.get<GetModelsResponse<TModel>>(
    config.modelPath,
    {
      params: axiosParams,
    }
  );

  return data;
};

export const useModelsQuery = <TModel>(
  config: ModelConfig,
  { fetchCount, ...otherProps }: Record<string, string>
) => {
  const _ = useInfiniteQuery(
    [
      config.modelPath,
      {
        ...otherProps,
      },
    ] as [string, Record<string, string>],
    (props) => getModels<TModel>({ ...props, config }),
    {
      keepPreviousData: true,
      getNextPageParam: (lastPage) => lastPage.cursor ?? undefined,
      meta: {
        fetchCount,
      },
    }
  );
  return _;
};
