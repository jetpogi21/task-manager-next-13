import { GetModelsResponse } from "@/interfaces/GeneralInterfaces";
import { ModelConfig } from "@/interfaces/ModelConfig";
import axiosClient from "@/utils/api";
import {
  findModelPrimaryKeyField,
  getAxiosParams,
  getDefaultFilters,
} from "@/utils/utilities";
import {
  QueryKey,
  QueryMeta,
  useInfiniteQuery,
  useMutation,
  useQuery,
} from "@tanstack/react-query";

export const updateModels = async <T>(payload: T, config: ModelConfig) => {
  const { data } = await axiosClient({
    url: `${config.modelPath}/multi`,
    method: "post",
    data: payload,
  });

  return data as unknown;
};

export const useUpdateModelsMutation = (modelConfig: ModelConfig) => {
  const modelMutation = useMutation({
    mutationFn: async (payload) => updateModels(payload, modelConfig),
  });

  return modelMutation;
};

export const deleteModels = async (
  payload: Record<"deletedRecords", number[] | string[]>,
  config: ModelConfig
) => {
  const { data } = await axiosClient({
    url: `${config.modelPath}`,
    method: "delete",
    data: payload,
  });

  return data as unknown;
};

const updateModel = async (
  payload: Record<string, unknown>,
  id: string | number,
  config: ModelConfig
) => {
  const { data } = await axiosClient({
    url: config.modelPath + "/" + id,
    method: "put",
    data: payload,
  });

  return data;
};

const addModel = async (
  payload: Record<string, unknown>,
  config: ModelConfig
) => {
  const { data } = await axiosClient({
    url: config.modelPath,
    method: "post",
    data: payload,
  });

  return data;
};

export const getModel = async <TModel>(
  modelConfig: ModelConfig,
  slug: string
) => {
  const { data } = await axiosClient.get<TModel>(
    `${modelConfig.modelPath}/${slug}`
  );
  return data;
};

const addOrUpdateModel = (
  payload: Record<string, unknown>,
  config: ModelConfig
): Promise<Record<string, unknown>> => {
  const primaryKeyField = findModelPrimaryKeyField(config).fieldName;
  if (payload[primaryKeyField!]) {
    return updateModel(
      payload,
      payload[primaryKeyField!] as string | number,
      config
    );
  } else {
    return addModel(payload, config);
  }
};

export const useModelQuery = (
  modelConfig: ModelConfig,
  id: string,
  options?: Omit<Parameters<typeof useQuery>[0], "queryKey" | "queryFn">
) => {
  const modelMutation = useMutation({
    //@ts-ignore
    mutationFn: async (payload) => addOrUpdateModel(payload, modelConfig),
  });
  const modelQuery = useQuery({
    queryKey: [modelConfig.modelPath, id],
    queryFn: () => getModel(modelConfig, id),
    ...options,
  });

  return { modelMutation, modelQuery };
};

export const useModelMutation = () => {};

//Generated by GetCodeOriginallyFromModelTable - GetCodeOriginallyFromModelTable
interface GetModelsProps {
  pageParam?: unknown;
  queryKey: QueryKey;
  meta: QueryMeta | undefined;
  config: ModelConfig;
}

const getModels = async <TModel>({
  pageParam = "",
  queryKey,
  meta,
  config,
}: GetModelsProps) => {
  const inferredQueryKey = queryKey as [string, Record<string, string>];
  const [_, { limit, sort, ...otherQueryKeys }] = inferredQueryKey;

  const { fetchCount } = meta!;
  const defaultFilters = getDefaultFilters(config.filters);

  const axiosParams = getAxiosParams(
    {
      ...(otherQueryKeys as Record<string, string>),
    },
    defaultFilters,
    {
      cursor: pageParam as string,
      limit,
      sort,
      //@ts-ignore
      fetchCount: fetchCount.toString(),
    }
  ) as Partial<TModel>;

  const { data } = await axiosClient.get<GetModelsResponse<TModel>>(
    config.modelPath,
    {
      params: axiosParams,
    }
  );

  return data;
};

export const useModelsQuery = <TModel>(
  config: ModelConfig,
  { fetchCount, ...otherProps }: Record<string, string>
) => {
  const _ = useInfiniteQuery({
    queryKey: [
      config.modelPath,
      {
        ...otherProps,
      },
    ] as [string, Record<string, string>],
    queryFn: ({ queryKey, pageParam, meta }) =>
      getModels<TModel>({ queryKey, pageParam, meta, config }),
    initialPageParam: "",
    getNextPageParam: (lastPage) => lastPage.cursor ?? undefined,
    meta: {
      fetchCount,
    },
  });
  return _;
};
