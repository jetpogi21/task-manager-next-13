//Generated by WriteToUsemodelquery_ts - useModelQuery.ts
import {
  GetTagsResponse,
  TagDeletePayload,
  TagFormUpdatePayload,
  TagModel,
  TagSearchParams,
  TagUpdatePayload,
} from "@/interfaces/TagInterfaces";
import axiosClient from "@/utils/api";
import {
  DEFAULT_FILTERS,
  MODEL_PATH,
  PRIMARY_KEY,
} from "@/utils/constants/TagConstants";
import { getAxiosParams } from "@/utils/utilities";
import {
  QueryMeta,
  UseQueryResult,
  useInfiniteQuery,
  useMutation,
  useQuery,
} from "@tanstack/react-query";

type IndexAndID = {
  index: number;
  id: number | string;
};

type Response = {
  id?: number | string;
  slug?: string;
  //Generated by GetAllRelatedIndexAndID
  TaskTags: IndexAndID[];
};

export const updateTags = async (payload: TagUpdatePayload) => {
  const { data } = (await axiosClient({
    url: `${MODEL_PATH}/multi`,
    method: "post",
    data: payload,
  })) as { data: { recordsCreated: number } };

  return data;
};

export const deleteTags = async (payload: TagDeletePayload) => {
  const { data } = (await axiosClient({
    url: `${MODEL_PATH}`,
    method: "delete",
    data: payload,
  })) as { data: { recordsDeleted: number } };

  return data;
};

const updateTag = async (
  payload: TagFormUpdatePayload,
  id: string | number
) => {
  const { data } = await axiosClient({
    url: MODEL_PATH + "/" + id,
    method: "put",
    data: payload,
  });

  return data as Response;
};

const addTag = async (payload: TagFormUpdatePayload) => {
  const { data } = await axiosClient({
    url: MODEL_PATH,
    method: "post",
    data: payload,
  });

  return data as Response;
};

export const getTag = async ({ queryKey }: { queryKey: [string, string] }) => {
  const { data } = await axiosClient.get<TagModel>(
    `${MODEL_PATH}/${queryKey[1]}`
  );
  return data;
};

const addOrUpdateTag = (payload: TagFormUpdatePayload) => {
  if (payload[PRIMARY_KEY]) {
    return updateTag(payload, payload[PRIMARY_KEY]);
  } else {
    return addTag(payload);
  }
};

export const useTagQuery = (
  slug: string,
  options?: Parameters<typeof useQuery>[2]
) => {
  const tagMutation = useMutation(addOrUpdateTag);

  const tagQuery = useQuery(
    ["tag", slug],
    getTag,
    //@ts-ignore
    options
  ) as UseQueryResult<TagModel, any>;

  return { tagMutation, tagQuery };
};

//Generated by GetCodeOriginallyFromModelTable - GetCodeOriginallyFromModelTable
interface GetTagsProps {
  pageParam?: string;
  queryKey: [string, Partial<TagSearchParams>];
  meta: QueryMeta | undefined;
}
const getTags = async ({ pageParam = "", queryKey, meta }: GetTagsProps) => {
  const [
    _,
    {
      //Generated by GetAllQueryKeyValueOfGetPluralizedModelName
      q = "", //Generated by GetQueryKeyValueOfGetPluralizedModelName - GetQueryKeyValueOfGetPluralizedModelName
      limit = "",
      sort = "",
    },
  ] = queryKey;

  const { fetchCount } = meta!;

  const axiosParams = getAxiosParams(
    {
      //Generated by GetAllFilterQueryNameBySeqModel
      q,
    },
    DEFAULT_FILTERS,
    {
      cursor: pageParam,
      limit,
      sort,
      //@ts-ignore
      fetchCount: fetchCount.toString(),
    }
  ) as Partial<TagSearchParams>;

  const { data } = await axiosClient.get<GetTagsResponse>(MODEL_PATH, {
    params: axiosParams,
  });

  return data;
};

interface UseTagsQueryProps extends Partial<TagSearchParams> {}

export const useTagsQuery = ({
  //Generated by GetAllFilterQueryNameBySeqModel
  q,
  limit,
  sort,
  fetchCount,
}: UseTagsQueryProps) => {
  const _ = useInfiniteQuery(
    [
      "tags",
      {
        //Generated by GetAllFilterQueryNameBySeqModel
        q,
        limit,
        sort,
      },
    ],
    getTags,
    {
      keepPreviousData: true,
      getNextPageParam: (lastPage) => lastPage.cursor ?? undefined,
      meta: {
        fetchCount,
      },
    }
  );
  return _;
};
