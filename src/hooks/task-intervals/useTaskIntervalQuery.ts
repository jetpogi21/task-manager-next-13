//Generated by WriteToUsemodelquery_ts - useModelQuery.ts
import {
  GetTaskIntervalsResponse,
  TaskIntervalDeletePayload,
  TaskIntervalFormUpdatePayload,
  TaskIntervalModel,
  TaskIntervalSearchParams,
  TaskIntervalUpdatePayload,
} from "@/interfaces/TaskIntervalInterfaces";
import axiosClient from "@/utils/api";
import {
  DEFAULT_FILTERS,
  MODEL_PATH,
  PRIMARY_KEY,
} from "@/utils/constants/TaskIntervalConstants";
import { getAxiosParams } from "@/utils/utilities";
import {
  QueryMeta,
  UseQueryResult,
  useInfiniteQuery,
  useMutation,
  useQuery,
} from "@tanstack/react-query";

type IndexAndID = {
  index: number;
  id: number | string;
};

type Response = {
  id?: number | string;
  slug?: string;
  //Generated by GetAllRelatedIndexAndID
  Tasks: IndexAndID[];
  TaskTemplates: IndexAndID[];
};

export const updateTaskIntervals = async (
  payload: TaskIntervalUpdatePayload
) => {
  const { data } = (await axiosClient({
    url: `${MODEL_PATH}/multi`,
    method: "post",
    data: payload,
  })) as { data: { recordsCreated: number } };

  return data;
};

export const deleteTaskIntervals = async (
  payload: TaskIntervalDeletePayload
) => {
  const { data } = (await axiosClient({
    url: `${MODEL_PATH}`,
    method: "delete",
    data: payload,
  })) as { data: { recordsDeleted: number } };

  return data;
};

const updateTaskInterval = async (
  payload: TaskIntervalFormUpdatePayload,
  id: string | number
) => {
  const { data } = await axiosClient({
    url: MODEL_PATH + "/" + id,
    method: "put",
    data: payload,
  });

  return data as Response;
};

const addTaskInterval = async (payload: TaskIntervalFormUpdatePayload) => {
  const { data } = await axiosClient({
    url: MODEL_PATH,
    method: "post",
    data: payload,
  });

  return data as Response;
};

export const getTaskInterval = async ({
  queryKey,
}: {
  queryKey: [string, string];
}) => {
  const { data } = await axiosClient.get<TaskIntervalModel>(
    `${MODEL_PATH}/${queryKey[1]}`
  );
  return data;
};

const addOrUpdateTaskInterval = (payload: TaskIntervalFormUpdatePayload) => {
  if (payload[PRIMARY_KEY]) {
    return updateTaskInterval(payload, payload[PRIMARY_KEY]);
  } else {
    return addTaskInterval(payload);
  }
};

export const useTaskIntervalQuery = (
  slug: string,
  options?: Parameters<typeof useQuery>[2]
) => {
  const taskIntervalMutation = useMutation(addOrUpdateTaskInterval);

  const taskIntervalQuery = useQuery(
    ["taskInterval", slug],
    getTaskInterval,
    //@ts-ignore
    options
  ) as UseQueryResult<TaskIntervalModel, any>;

  return { taskIntervalMutation, taskIntervalQuery };
};

//Generated by GetCodeOriginallyFromModelTable - GetCodeOriginallyFromModelTable
interface GetTaskIntervalsProps {
  pageParam?: string;
  queryKey: [string, Partial<TaskIntervalSearchParams>];
  meta: QueryMeta | undefined;
}
const getTaskIntervals = async ({
  pageParam = "",
  queryKey,
  meta,
}: GetTaskIntervalsProps) => {
  const [
    _,
    {
      //Generated by GetAllQueryKeyValueOfGetPluralizedModelName
      q = "", //Generated by GetQueryKeyValueOfGetPluralizedModelName - GetQueryKeyValueOfGetPluralizedModelName
      limit = "",
      sort = "",
    },
  ] = queryKey;

  const { fetchCount } = meta!;

  const axiosParams = getAxiosParams(
    {
      //Generated by GetAllFilterQueryNameBySeqModel
      q,
    },
    DEFAULT_FILTERS,
    {
      cursor: pageParam,
      limit,
      sort,
      //@ts-ignore
      fetchCount: fetchCount.toString(),
    }
  ) as Partial<TaskIntervalSearchParams>;

  const { data } = await axiosClient.get<GetTaskIntervalsResponse>(MODEL_PATH, {
    params: axiosParams,
  });

  return data;
};

interface UseTaskIntervalsQueryProps
  extends Partial<TaskIntervalSearchParams> {}

export const useTaskIntervalsQuery = ({
  //Generated by GetAllFilterQueryNameBySeqModel
  q,
  limit,
  sort,
  fetchCount,
}: UseTaskIntervalsQueryProps) => {
  const _ = useInfiniteQuery(
    [
      "taskIntervals",
      {
        //Generated by GetAllFilterQueryNameBySeqModel
        q,
        limit,
        sort,
      },
    ],
    getTaskIntervals,
    {
      keepPreviousData: true,
      getNextPageParam: (lastPage) => lastPage.cursor ?? undefined,
      meta: {
        fetchCount,
      },
    }
  );
  return _;
};
